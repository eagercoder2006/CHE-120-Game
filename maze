import random

def validMoveExists(currentTile):
    valid = False
    if currentTile[0] > 2 and maze[currentTile[0] - 2][currentTile[1]] != " ": #N
        validMoves.append(0)
        valid = True
    if currentTile[1] > 2 and maze[currentTile[0]][currentTile[1] - 2] != " ": #W
        validMoves.append(1)
        valid = True
    if currentTile[0] < mazeSize - 2 and maze[currentTile[0] + 2][currentTile[1]] != " ": #SOUTH
        validMoves.append(2)
        valid = True
    if currentTile[1] < mazeSize - 2 and maze[currentTile[0]][currentTile[1] + 2] != " ": #E
        validMoves.append(3)
        valid = True
    return valid

maze = []
mazeSize = 25
#fill all spots with walls first
for i in range(mazeSize):
    row = []
    for j in range(mazeSize):
        row.append(chr(9608))
    maze.append(row)

#Carve out random path, going only north and west
paths = []
x = mazeSize - 2
y = mazeSize - 2
maze[y][x] = " "
maze[y + 1][x] = " "
paths.append((y+1, x))
paths.append((y, x))
current = 0
while x > 1 and y > 1:
    direction = random.randint(0,10)
    if direction >= 2:
        direction = abs(current - 1)
    if direction == 0 and y > 2:
        maze[y - 1][x] = " "
        maze[y - 2][x] = " "
        paths.append((y-1,x))
        paths.append((y-2,x))
        y = y - 2
        current = 0
    elif direction == 1 and x > 2:
        maze[y][x - 1] = " "
        maze[y][x - 2] = " "
        paths.append((y,x-1))
        paths.append((y,x-2))
        x = x - 2
        current = 1

#fill in the remaining spots
if x <= 1:
   for i in range(y):
       maze[i][1] = " "
       paths.append((y-i-1,1))
else:
    for i in range(1,x):
        maze[1][i] = " "
        paths.append((1,x-i))
    paths.append((0,1))
    maze[0][1] = " "     

#BRACHING PATHS

currentTile = (mazeSize - 2, mazeSize - 2)
for i in range(1, len(paths), 2):
    validMoves = []
    while True:
        validMoves.clear()
        if validMoveExists(currentTile):
            direction = validMoves[random.randint(0,len(validMoves)) - 1]
            if direction == 0: #NORTH
                maze[currentTile[0] - 1][currentTile[1]] = " "
                maze[currentTile[0] - 2][currentTile[1]] = " "
                paths.append((currentTile[0] - 1, currentTile[1]))
                paths.append((currentTile[0] - 2, currentTile[1]))
                currentTile = (currentTile[0] - 2, currentTile[1])
            elif direction == 1: #WEST
                maze[currentTile[0]][currentTile[1] - 1] = " "
                maze[currentTile[0]][currentTile[1] - 2] = " "
                paths.append((currentTile[0], currentTile[1] - 1))
                paths.append((currentTile[0], currentTile[1] - 2))
                currentTile = (currentTile[0], currentTile[1] - 2)
            elif direction == 2: #SOUTH
                maze[currentTile[0] + 1][currentTile[1]] = " "
                maze[currentTile[0] + 2][currentTile[1]] = " "
                paths.append((currentTile[0] + 1, currentTile[1]))
                paths.append((currentTile[0] + 2, currentTile[1]))
                currentTile = (currentTile[0] + 2, currentTile[1])
            else: #EAST
                maze[currentTile[0]][currentTile[1] + 1] = " "
                maze[currentTile[0]][currentTile[1] + 2] = " "
                paths.append((currentTile[0], currentTile[1] + 1))
                paths.append((currentTile[0], currentTile[1] + 2))
                currentTile = (currentTile[0], currentTile[1] + 2)
        else:
            currentTile = paths[i] #backtrack to original tile
            break

#print(paths)
#show the maze
for i in range(mazeSize):
    for j in range(mazeSize):
        print(maze[i][j], end="")
    print()
        
snakes = {}
ladders = {}

#Generating ladders
for i in range(len(paths) // 45):
    start = random.randint(0, len(paths) - 1)
    end = random.randint(0, len(paths) - 1)
    while paths[start][0] <= paths[end][0] or paths[start] in ladders:
        start = random.randint(0, len(paths) - 1)
        end = random.randint(0, len(paths) - 1)
    ladders[paths[start]] = paths[end]
    maze[paths[start][0]][paths[start][1]] = chr(i+65)
    maze[paths[end][0]][paths[end][1]] = chr(i+65)
print(ladders)
print()


#Generating snakes
for i in range(len(paths) // 45):
    start = random.randint(0, len(paths) - 1)
    end = random.randint(0, len(paths) - 1)
    while paths[start][0] >= paths[end][0] or paths[start] in snakes or paths[start] in ladders:
        start = random.randint(0, len(paths) - 1)
        end = random.randint(0, len(paths) - 1)
    snakes[paths[start]] = paths[end]
    maze[paths[start][0]][paths[start][1]] = chr(i+97)
    maze[paths[end][0]][paths[end][1]] = chr(i+97)

#print(snakes)
#show the board
for i in range(mazeSize):
    for j in range(mazeSize):
        print(maze[i][j], end="")
    print()
